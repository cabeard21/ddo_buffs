The error message "TypeError: unhashable type: 'numpy.ndarray'" indicates that a numpy array is being used as a key in a dictionary. In Python, only immutable types can be used as dictionary keys. The numpy array is mutable and hence cannot be used as a key.

Looking at the code, the error is likely occurring in the `buff_timer.update(buff, time)` line in the `main.py` file. Here, `buff` is a tuple containing a string and a numpy array. The numpy array in this tuple is causing the error.

To fix this, we can modify the `buff` to only include the string (buff name) and not the numpy array (image data). This can be done in the `detect` method of the `BuffDetector` class in the `buff_detector.py` file. Instead of returning a tuple of the buff name and image data, we can just return the buff name.

Here are the modified files:

buff_detector.py
```python
import cv2
import numpy as np
import os
import pyautogui
import logging

class BuffDetector:
    # ... rest of the code ...

    def detect(self):
        # ... rest of the code ...

        buffs = []
        for name, template in self.templates.items():
            # ... rest of the code ...

            # Only append the buff name, not the image data
            buffs.append(name)
            self.logger.info(f"Match template result for {name}: {max_loc}")

            # ... rest of the code ...

        return buffs

    # ... rest of the code ...
```

main.py
```python
import json
from buff_detector import BuffDetector
from buff_timer import BuffTimer
from buff_bar import BuffBar
from buff_sorter import BuffSorter
from buff_ocr import BuffOCR
from pathlib import Path

BASE = Path(__file__).resolve().parent

def main():
    # ... rest of the code ...

    while True:
        # Detect buffs
        buffs = buff_detector.detect()

        # Update timers and bars
        for buff_name in buffs:
            # Read timer
            time = buff_ocr.read(buff_name)

            # Update timer
            buff_timer.update(buff_name, time)

            # Update bar
            buff_bar.update(buff_name, buff_timer.get_remaining(buff_name))

        # ... rest of the code ...

if __name__ == "__main__":
    main()
```

This should fix the TypeError. The `buff` now only contains the buff name (a string), which is hashable and can be used as a dictionary key.